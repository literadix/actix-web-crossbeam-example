use std::sync::{Mutex};

use actix_web::{App, HttpServer, web};
use std::{thread, time};

// // #[derive(Copy, Clone)]
struct AppStateWithCounter {
    counter: Mutex<i32>, // <- Mutex is necessary to mutate safely across threads
}

impl AppStateWithCounter {

    fn delayed_add(&self) {
        &self.add_one();
    }

    fn add_one(&self) {
        let mut counter = self.counter.lock().unwrap();
        *counter += 1
    }

    fn get_counter(&self) -> i32
    {
        let counter = self.counter.lock().unwrap();
        *counter
    }
}

async fn index(data: web::Data<AppStateWithCounter>) -> String {

    data.delayed_add();
    data.add_one();
    format!("Request number: {}", data.get_counter()) // <- response with count
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {

    let counter = web::Data::new(AppStateWithCounter {
        counter: Mutex::new(0),
    });

    // https://users.rust-lang.org/t/actix-web-with-a-separate-consumer-thread/55854/2
    let _handle = thread::spawn(move|| loop {
            println!("{:?}", counter.get_counter());
            thread::sleep(time::Duration::from_secs(1));
    });

    HttpServer::new(move || {
        // move counter into the closure
        App::new()
            // Note: using app_data instead of data
            .app_data(counter.clone()) // <- register the created data
            .route("/", web::get().to(index))
    })
        .bind("127.0.0.1:8080")?
        .run()
        .await


}